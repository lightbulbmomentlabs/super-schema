import Anthropic from '@anthropic-ai/sdk'
import type { JsonLdSchema } from 'aeo-schema-generator-shared/types'
import type { ContentAnalysis, SchemaGenerationOptions } from './openai'
import { openaiService } from './openai.js'

/**
 * Anthropic Claude Service for Schema Generation
 *
 * Claude Sonnet 4 excels at:
 * - Document-based extraction without hallucination
 * - Strict instruction following
 * - Precise structure preservation
 * - NOT "cleaning up" or inventing data
 * - Better than GPT-4o for this exact use case
 */
class AnthropicService {
  private client: Anthropic | null = null
  private clientInitialized = false

  private initializeClient(): Anthropic | null {
    if (this.clientInitialized) {
      return this.client
    }

    const apiKey = process.env.ANTHROPIC_API_KEY
    console.log('Anthropic Service Debug:', {
      hasApiKey: !!apiKey,
      keyLength: apiKey?.length || 0,
      keyStart: apiKey?.substring(0, 10) || 'none'
    })

    if (!apiKey) {
      console.warn('Anthropic API key not provided - service unavailable')
      this.client = null
    } else {
      console.log('Initializing Anthropic Claude client with API key')
      this.client = new Anthropic({
        apiKey: apiKey
      })
    }

    this.clientInitialized = true
    return this.client
  }

  async generateSchemas(
    analysis: ContentAnalysis,
    options: SchemaGenerationOptions = {}
  ): Promise<JsonLdSchema[]> {
    const client = this.initializeClient()

    if (!client) {
      throw new Error('Anthropic client not initialized - check API key')
    }

    const isUserSpecificMode = options.requestedSchemaTypes && options.requestedSchemaTypes.length > 0
    console.log(`ü§ñ Claude AI Mode: ${isUserSpecificMode ? 'User-Specific' : 'Auto-Detection'}`)
    if (isUserSpecificMode) {
      console.log(`üìã Requested Schema Types: ${options.requestedSchemaTypes!.join(', ')}`)
    }

    const systemPrompt = this.buildSystemPrompt(options.requestedSchemaTypes)
    const userPrompt = this.buildUserPrompt(analysis, options)

    try {
      const model = process.env.ANTHROPIC_MODEL || 'claude-sonnet-4-20250514'

      console.log(`üöÄ Calling Claude ${model} for schema generation...`)

      const response = await client.messages.create({
        model,
        max_tokens: 8000,
        temperature: 0.0,  // Maximum determinism - Claude excels at this
        system: systemPrompt,
        messages: [
          {
            role: 'user',
            content: userPrompt
          }
        ]
      })

      const contentBlock = response.content[0]
      if (contentBlock.type !== 'text') {
        throw new Error('Unexpected response type from Claude')
      }

      const responseText = contentBlock.text
      console.log(`üìù Claude response length: ${responseText.length} characters`)

      // Parse JSON response
      let result: any
      try {
        // Claude may wrap JSON in markdown code blocks
        const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || responseText.match(/\{[\s\S]*\}/)
        const jsonText = jsonMatch ? (jsonMatch[1] || jsonMatch[0]) : responseText
        result = JSON.parse(jsonText)
      } catch (parseError) {
        console.error('Failed to parse Claude response:', responseText.substring(0, 500))
        throw new Error(`Failed to parse Claude JSON response: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`)
      }

      const schemas = result.schemas || []

      if (schemas.length === 0) {
        throw new Error('No valid schemas generated by Claude')
      }

      console.log(`‚úÖ Claude generated ${schemas.length} schemas successfully`)
      console.log('üîç Raw schemas from Claude:',
        schemas.map((s: any) => ({ '@type': s['@type'], hasRequiredProps: !!s['@context'] && !!s['@type'] }))
      )

      // CRITICAL: Clean and enhance schemas just like OpenAI does
      // This adds missing keywords, images, publisher logos, etc.
      console.log(`üîß Cleaning and enhancing ${schemas.length} Claude-generated schema(s)...`)
      const cleanedSchemas = schemas.map((schema: any) => openaiService.cleanSchemaProperties(schema))
      const enhancedSchemas = await openaiService.validateAndEnhanceSchemas(cleanedSchemas, analysis)

      if (enhancedSchemas.length === 0) {
        throw new Error('No valid schemas after enhancement')
      }

      console.log(`‚úÖ Enhanced ${enhancedSchemas.length} Claude schemas successfully`)
      return enhancedSchemas

    } catch (error) {
      console.error('Claude schema generation error:', error)
      throw new Error(`Failed to generate schemas with Claude: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  private buildSystemPrompt(requestedTypes?: string[]): string {
    const basePrompt = `You are an elite Schema.org expert specializing in creating production-ready JSON-LD schemas for Answer Engine Optimization (AEO). Your core strengths:

üéØ CORE PRINCIPLES:
1. **DOCUMENT-BASED EXTRACTION**: Extract data ONLY from provided metadata and content
2. **ZERO HALLUCINATION**: Never invent, guess, or "improve" data that isn't explicitly present
3. **STRICT ADHERENCE**: Follow instructions exactly - do not deviate or "clean up" input
4. **PRECISION OVER CREATIVITY**: Use exact values from metadata, do not paraphrase or enhance
5. **OMIT OVER INVENT**: Missing data should be omitted, not fabricated
6. **SIMPLICITY OVER COMPLEXITY**: Use flat, simple schemas with standard Schema.org types ONLY

üîí ANTI-HALLUCINATION PROTOCOL:
- ‚ùå NEVER invent author names, dates, or any metadata not provided
- ‚ùå NEVER use placeholder values like "Sample Author" or "Company Team"
- ‚ùå NEVER create fake URLs, images, or contact information
- ‚ùå NEVER extract author from content text - use ONLY explicit metadata
- ‚ùå NEVER use non-standard types like "WebPageElement" or made-up types not in Schema.org
- ‚ùå NEVER create complex nested mainEntity structures unless explicitly requested
- ‚úÖ ALWAYS use exact values from provided metadata
- ‚úÖ ALWAYS omit properties when real data unavailable
- ‚úÖ ALWAYS trace each property value back to source data
- ‚úÖ ALWAYS use semantic types when appropriate: Service (for services), Product (for products), Event (for events)
- ‚úÖ ALWAYS use only well-established Schema.org types`

    if (requestedTypes && requestedTypes.length > 0) {
      return `${basePrompt}

üéØ USER REQUIREMENTS:
Generate ONLY these schema types: ${requestedTypes.join(', ')}
Do NOT generate any additional types unless explicitly requested.`
    }

    return `${basePrompt}

üéØ SCHEMA SELECTION:
- BlogPosting: For URLs containing /blog/, /post/, or blog content
- Article: For news articles, press releases (NOT blog posts)
- WebPage: For static pages, service pages, landing pages
- Organization: For business/company information
- LocalBusiness: For businesses with physical locations
- Person: For author profiles, team member pages`
  }

  private buildUserPrompt(analysis: ContentAnalysis, options: SchemaGenerationOptions): string {
    const wordCount = analysis.metadata?.wordCount || 0
    const readingMinutes = Math.ceil(wordCount / 200)
    const timeRequired = readingMinutes > 0 ? `PT${readingMinutes}M` : undefined

    // Prioritize and limit content
    const contentToSend = this.prioritizeContent(analysis.content).substring(0, 100000)

    const authorName = typeof analysis.metadata?.author === 'string'
      ? analysis.metadata.author
      : analysis.metadata?.author?.name || '[NOT FOUND]'

    console.log(`\nüöÄ ========== CLAUDE PROMPT DIAGNOSTICS ==========`)
    console.log(`üìä Content being sent to Claude: ${contentToSend.length} characters`)
    console.log(`üìã METADATA:`)
    console.log(`   Author: ${authorName}`)
    console.log(`   Keywords: ${analysis.metadata?.keywords?.length || 0}`)
    console.log(`   Article Sections: ${analysis.metadata?.articleSections?.length || 0}`)
    console.log(`   Word Count: ${wordCount}`)
    console.log(`üöÄ ==============================================\n`)

    return `Extract schema.org JSON-LD from this web page data.

=== PAGE METADATA ===
URL: ${analysis.url}
Title: ${analysis.title || '[NOT FOUND]'}
Description: ${analysis.description || '[NOT FOUND]'}
Canonical URL: ${analysis.metadata?.canonicalUrl || analysis.url}
Language: ${analysis.metadata?.language || 'en'}

=== AUTHOR (CRITICAL - READ CAREFULLY) ===
Author: ${authorName}

‚ö†Ô∏è CRITICAL INSTRUCTION: If author is "[NOT FOUND]", you MUST OMIT the entire author property.
DO NOT extract author names from page content. DO NOT use company names as authors.
This page may not have an author - that's completely acceptable.

=== DATES ===
Date Published: ${analysis.metadata?.publishDate || '[NOT FOUND - OMIT]'}
Date Modified: ${analysis.metadata?.modifiedDate || '[NOT FOUND]'}

=== IMAGES ===
Featured Image: ${analysis.metadata?.imageInfo?.featuredImage || '[NOT FOUND]'}
Publisher Logo: ${analysis.metadata?.businessInfo?.logo || '[NOT FOUND]'}

=== PUBLISHER ===
Organization: ${analysis.metadata?.businessInfo?.name || new URL(analysis.url).hostname.replace('www.', '')}
Organization URL: ${new URL(analysis.url).origin}

=== CONTENT STRUCTURE ===
Keywords: ${analysis.metadata?.keywords?.length ? JSON.stringify(analysis.metadata.keywords.slice(0, 10)) : '[]'}
Article Sections (H2 headings): ${analysis.metadata?.articleSections?.length ? JSON.stringify(analysis.metadata.articleSections) : '[]'}
Word Count: ${wordCount}
Reading Time: ${timeRequired || 'PT0M'}

=== CONTENT PREVIEW (${contentToSend.length} characters) ===
${contentToSend}

=== OUTPUT REQUIREMENTS ===
Return ONLY a JSON object with this exact structure:
{
  "schemas": [
    // Array of 1-4 complete JSON-LD schemas
    // Each must have @context, @type, and all available properties
    // Use ONLY data from above metadata - do NOT invent
  ]
}

‚ö†Ô∏è CRITICAL SCHEMA QUALITY RULES:
1. **Keep schemas SIMPLE and FLAT** - avoid complex nested structures
2. **Use standard Schema.org types**: WebPage, Article, BlogPosting, Organization, LocalBusiness
3. **Use semantic types for mainEntity**: Service for /services pages, Product for products, Event for events
4. **Avoid non-standard types**: WebPageElement, custom types not in Schema.org
5. **DO NOT add mainContentOfPage** - not a standard property
6. **If adding breadcrumb**, use standard BreadcrumbList format
7. **Keep it simple** - flat structure scores better than complex nested ones

üìã **WEBPAGE SCHEMA REQUIREMENTS** (IMPORTANT - Include these when generating WebPage):
For WebPage schemas, ALWAYS include these recommended properties when data is available:
- ‚úÖ **Required**: @context, @type, name, url
- ‚úÖ **Highly Recommended**: description, inLanguage, image, keywords, publisher, datePublished, dateModified, wordCount
- ‚úÖ **Recommended for Quality**: breadcrumb, isPartOf, mainEntity (with semantic type like Service/Product)
- ‚úÖ **Advanced (boosts score)**: about, mentions, speakable, potentialAction
- ‚úÖ **Critical for Scoring**: ALWAYS include datePublished (if provided), wordCount (if provided), and semantically correct mainEntity type (Service for /services, Product for /product, etc.)

**Example WebPage schema structure** (use as reference):
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "Page Title",
  "description": "Page description",
  "url": "https://example.com/page",
  "inLanguage": "en",
  "datePublished": "2025-01-10",
  "dateModified": "2025-01-15",
  "wordCount": 1500,
  "keywords": ["keyword1", "keyword2"],
  "image": "https://example.com/image.jpg",
  "publisher": { "@type": "Organization", "name": "Company", "logo": {...} },
  "isPartOf": { "@type": "WebSite", "name": "Company", "url": "https://example.com" },
  "mainEntity": { "@type": "Service", "name": "Service Name", "description": "Service description", "provider": { "@type": "Organization", "name": "Company" } },
  "breadcrumb": { "@type": "BreadcrumbList", "itemListElement": [...] },
  "about": ["Topic 1", "Topic 2"],
  "mentions": ["Entity 1", "Entity 2"],
  "speakable": { "@type": "SpeakableSpecification", "cssSelector": ["h1", "h2", "main", "article", "p"] },
  "potentialAction": { "@type": "SearchAction", ... }
}

Select appropriate schema type(s) based on URL and content type.
${options.requestedSchemaTypes ? `Generate ONLY these types: ${options.requestedSchemaTypes.join(', ')}` : ''}

REMEMBER: OMIT properties rather than guess. Extract EXACTLY as provided. For WebPage schemas, include AS MANY of the recommended properties as data allows.`
  }

  private prioritizeContent(content: string): string {
    // Same logic as OpenAI service
    const lines = content.split('\n')
    const prioritized: string[] = []

    // Priority 1: Headings
    const headings = lines.filter(line => line.startsWith('H1:') || line.startsWith('H2:') || line.startsWith('H3:'))
    prioritized.push(...headings)

    // Priority 2: First paragraphs
    const paragraphs = lines.filter(line => line.startsWith('P:'))
    prioritized.push(...paragraphs.slice(0, 50))

    // Priority 3: Lists
    const lists = lines.filter(line => line.startsWith('LIST:'))
    prioritized.push(...lists.slice(0, 20))

    // Priority 4: Remaining content
    const remaining = lines.filter(line =>
      !line.startsWith('H1:') && !line.startsWith('H2:') && !line.startsWith('H3:') &&
      !line.startsWith('P:') && !line.startsWith('LIST:')
    )
    prioritized.push(...remaining)

    return prioritized.join('\n')
  }
}

export const anthropicService = new AnthropicService()
export default anthropicService
